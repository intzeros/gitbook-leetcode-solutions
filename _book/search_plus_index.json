{"./":{"url":"./","title":"Introduction","keywords":"","body":"gitbook-leetcode-solutions GitBook for LeetCode solutions. Demo: http://lszero.com/leetcode/ GitHub: https://github.com/lszero/gitbook-leetcode-solutions Setup $ npm install gitbook-cli -g $ git clone https://github.com/lszero/gitbook-leetcode-solutions.git $ cd gitbook-leetcode-solutions $ gitbook serve "},"favorite_list.html":{"url":"favorite_list.html","title":"Favorite list","keywords":"","body":"Favorite Problems ★★推荐： LeetCode 3. Longest Substring Without Repeating Characters LeetCode 5. Longest Palindromic Substring LeetCode 46&47. Permutations & Permutations II LeetCode 146. LRU Cache ★★★推荐： LeetCode 4. Median of Two Sorted Arrays LeetCode 44. Wildcard Matching "},"solutions/1. Two Sum.html":{"url":"solutions/1. Two Sum.html","title":"LeetCode 1. Two Sum","keywords":"","body":"LeetCode 1. Two Sum Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 解法一：O(nlogn)。先排序，再二分查找，或者从两头往中间查找的方式。 因为题目要求返回的是下标，除了用struct Node记录下标再排序之外，可以新开一个数组记录下标，然后利用lambda表达式对该数组进行排序，代码更简洁一些。 class Solution { public: vector twoSum(vector& nums, int target) { int n = nums.size(); vector idx(n); for(int i = 0; i rst; while(le target) ri--; else le++; } return rst; } }; 解法二：O(n)。hash查找。为了避免重复，用边插入边查找的方式。 class Solution { public: vector twoSum(vector& nums, int target) { int n = nums.size(); unordered_map hashMap; // vector rst; for(int i = 0; i "},"solutions/2. Add Two Numbers.html":{"url":"solutions/2. Add Two Numbers.html","title":"LeetCode 2. Add Two Numbers","keywords":"","body":"LeetCode 2. Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* p1 = l1, *p2 = l2; ListNode* H = new ListNode(0), *tail = H; int c = 0; while(p1 || p2 || c){ if(p1) c += p1->val; if(p2) c += p2->val; ListNode *q = new ListNode(c % 10); tail->next = q; tail = q; if(c >= 10) c = 1; else c = 0; if(p1) p1 = p1->next; if(p2) p2 = p2->next; } return H->next; } }; "},"solutions/3. Longest Substring Without Repeating Characters.html":{"url":"solutions/3. Longest Substring Without Repeating Characters.html","title":"LeetCode 3. Longest Substring Without Repeating Characters","keywords":"","body":"LeetCode 3. Longest Substring Without Repeating Characters Given a string, find the length of the longest substring without repeating characters. Examples: Given \"abcabcbb\", the answer is \"abc\", which the length is 3. Given \"bbbbb\", the answer is \"b\", with the length of 1. Given \"pwwkew\", the answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequenceand not a substring. （注意输入字符不止26个字母) class Solution { public: int lengthOfLongestSubstring(string s) { int n = s.size(); vector used(256, false); int i = 0, ans = 0, len = 0; for(int i = 0; i "},"solutions/4. Median of Two Sorted Arrays.html":{"url":"solutions/4. Median of Two Sorted Arrays.html","title":"LeetCode 4. Median of Two Sorted Arrays","keywords":"","body":"LeetCode 4. Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1: nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 O(log(min(N, M))). 思路： 将原问题转化为求第k大的数。 易想到分治算法。首先设想k比较小时（如取1、2），我们会怎么求？故分治策略跟k有关。 分治思路： 从已排好序的数组1中取前k1个数，数组2中取前k2个数（k1+k2=k. 为了达到更好的分治效果, 取k1 = k/2）。 （1）若nums1[k1] nums2[k2]，同（1）。 （3）若nums1[k1] == nums2[k2]，nums1[k1] 即为第k大的数。 总结起来就是, 每次扔掉 k/2个最大的数(若求 k-th 大), 然后更新 k 的值. int findKth(int nums1[], int n1, int nums2[], int n2, int k){ //always assume that n1 is equal or smaller than n2 if(n1 > n2) return findKth(nums2, n2, nums1, n1, k); if(n1 == 0) return nums2[k-1]; if(k == 1) return min(nums1[0], nums2[0]); // divide k into two parts int k1 = min(k/2, n1); int k2 = k-k1; if(nums1[k1-1] nums2[k2-1]){ return findKth(nums1, n1, nums2+k2, n2-k2, k-k2); }else{ return nums1[k1-1]; } } double findMedianSortedArrays(int nums1[], int n1, int nums2[], int n2) { if((n1+n2) & 1){ return findKth(nums1, n1, nums2, n2, (n1+n2)/2 + 1); }else{ return (findKth(nums1, n1, nums2, n2, (n1+n2)/2) + findKth(nums1, n1, nums2, n2, (n1+n2)/2 + 1)) / 2.0; } } "},"solutions/5. Longest Palindromic Substring.html":{"url":"solutions/5. Longest Palindromic Substring.html","title":"LeetCode 5. Longest Palindromic Substring","keywords":"","body":"LeetCode 5. Longest Palindromic Substring Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example: Input: \"babad\" Output: \"bab\" Note: \"aba\" is also a valid answer. Example: Input: \"cbbd\" Output: \"bb\" DP: isp[i][j]: 子串S(i, j)是否为回文串。 若子串S(i, j)是回文串，并且字符s[i-1] == s[j+1], 则子串S(i-1, j+1)也是回文串。 第二层 for 循环为逆推. class Solution { public: string longestPalindrome(string s) { int n = s.size(); vector> isp(n, vector(n, false)); int start = 0, len = 0; for(int i = 0; i = 0; j--){ if(s[i] == s[j] && (i-j len) len = i-j+1, start = j; } } } return s.substr(start, len); } }; "},"solutions/6. ZigZag Conversion.html":{"url":"solutions/6. ZigZag Conversion.html","title":"LeetCode 6. ZigZag Conversion","keywords":"","body":"LeetCode 6. ZigZag Conversion The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H N A P L S I I G Y I R And then read line by line: \"PAHNAPLSIIGYIR\" Write the code that will take a string and make this conversion given a number of rows: string convert(string text, int nRows); convert(\"PAYPALISHIRING\", 3) should return \"PAHNAPLSIIGYIR\" . 一开始我用的是周期性。T = numRows*2-2, 另外中间行还要多加一个s[idx + T-2*r]。 class Solution { public: string convert(string s, int numRows) { if(numRows == 1) return s; int n = s.size(); int T = (numRows 看到 leetcode discuss一种更简单的解法。 把每一行的遍历结果首先放到 vector 中。顺序遍历字符串s，将当前字符添加到对应行的vec[i]中。 class Solution { public: string convert(string s, int numRows) { vector vec(numRows); int k = 0, n = s.size(); while(k = 1; i--){ //斜向上方向 vec[i] += s[k++]; } } string rst; for(int i = 0; i "},"solutions/7. Reverse Integer.html":{"url":"solutions/7. Reverse Integer.html","title":"LeetCode 7. Reverse Integer","keywords":"","body":"LeetCode 7. Reverse Integer Reverse digits of an integer. Example1: x = 123, return 321 Example2: x = -123, return -321 注意细节： (1) 前置0 (2) 超出int范围（输出0） class Solution { public: int reverse(int x) { long long rst = 0; while(x){ rst = rst*10 + x%10; x /= 10; } int MAX = 0x7fffffff, MIN = 0x80000000; if(rst > MAX || rst "},"solutions/8. String to Integer-atoi.html":{"url":"solutions/8. String to Integer-atoi.html","title":"LeetCode 8. String to Integer (atoi)","keywords":"","body":"LeetCode 8. String to Integer (atoi) Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Update (2015-02-10): The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition. Four cases need to pay attention： whitespaces sign overflow invalid input class Solution { public: int myAtoi(string str) { long long x = 0; int n = str.size(), i = 0, sign = 1; while(i = '0' && str[i] MAX) return MAX; else if(sign == 0 && -x "},"solutions/9. Palindrome Number.html":{"url":"solutions/9. Palindrome Number.html","title":"LeetCode 9. Palindrome Number","keywords":"","body":"LeetCode 9. Palindrome Number Determine whether an integer is a palindrome. Do this without extra space. 最简单的方式：将后半段转置之后，再跟全半段比较。 将数字截取成两段的条件为：while(x > y). 有一点要注意：(x != 0 && x%10 == 0)这种情况需要特殊判断一下，比如20这个数字。 class Solution { public: bool isPalindrome(int x) { if(x y){ y = y*10 + x%10; x /= 10; } return x == y || y/10 == x; } }; "},"solutions/10. Regular Expression Matching.html":{"url":"solutions/10. Regular Expression Matching.html","title":"LeetCode 10. Regular Expression Matching","keywords":"","body":"LeetCode 10. Regular Expression Matching Implement regular expression matching with support for '.' and '*'. '.' Matches any single character. '*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). The function prototype should be: bool isMatch(const char *s, const char *p) Some examples: isMatch(\"aa\",\"a\") → false isMatch(\"aa\",\"aa\") → true isMatch(\"aaa\",\"aa\") → false isMatch(\"aa\", \"a*\") → true isMatch(\"aa\", \".*\") → true isMatch(\"ab\", \".*\") → true isMatch(\"aab\", \"c*a*b\") → true 不同于LeetCode 44. Wildcard Matching，这里的*号表示其前一个字符可以出现0次到多次。 DP, O(n*m)的解法。 注意 s=””, p=”.”时 -> false. class Solution { public: bool isMatch(string s, string p) { int n = s.size(), m = p.size(); vector> dp(n+1, vector(m+1, false)); dp[0][0] = true; for(int j = 1; j "},"solutions/11. Container With Most Water.html":{"url":"solutions/11. Container With Most Water.html","title":"LeetCode 11. Container With Most Water","keywords":"","body":"LeetCode 11. Container With Most Water Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. 贪心。le, ri指针从两端往中间走，并且height更短的那条先走。 class Solution { public: int maxArea(vector& height) { int le = 0, ri = height.size()-1, ans = 0; while(le ans) ans = area; if(height[le] "},"solutions/12&13. Integer to Roman & Roman to Integer.html":{"url":"solutions/12&13. Integer to Roman & Roman to Integer.html","title":"LeetCode 12&13. Integer to Roman & Roman to Integer","keywords":"","body":"LeetCode 12. Integer to Roman Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. 罗马数字采用七个罗马字母作数字，即 I（1）、V（5）、X（10）、L（50）、C（100）、D（500）、M（1000）。记数的方法： （1）相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ=3； （2）小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数，如 Ⅷ=8、Ⅻ=12； （3）小的数字（限于 Ⅰ、X 和 C）在大的数字的左边，所表示的数等于大数减小数得到的数，如 Ⅳ=4、Ⅸ=9. 不过像99，不能表示为IC (100-1)，而是XCIX (100-10+10-1). 例子： 299 499 599 899 999 CC XCIX CD XCIX D XCIX DCCC XCIX CM XCIX 200+99 (500-100)+99 500+99 (500+300)+99 (1000-100)+99 class Solution { public: string C[8] = {\"\", \"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"}; int D[8] = {5000, 1000, 500, 100, 50, 10, 5, 1 }; string intToRoman(int num) { string ans = \"\"; for(int i = 1; i 我写的解法需要将40和90分开处理，所以用了(i&1)。 网上看到更简的解法，不同于上面的C[]，D[]： string C[13] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}; int D[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 }; class Solution { public: string C[13] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}; int D[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 }; string intToRoman(int num) { string ans = \"\"; for(int i = 0; i = D[i]){ num -= D[i]; ans += C[i]; } } return ans; } }; LeetCode 13. Roman to Integer Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. class Solution { public: int getVal(char c){ switch(c){ case 'M': return 1000; case 'D': return 500; case 'C': return 100; case 'L': return 50; case 'X': return 10; case 'V': return 5; case 'I': return 1; } return 0; } int romanToInt(string s) { int n = s.size(); int ans = 0, i = 0; while(i "},"solutions/44. Wildcard Matching.html":{"url":"solutions/44. Wildcard Matching.html","title":"LeetCode 44. Wildcard Matching","keywords":"","body":"LeetCode 44. Wildcard Matching Implement wildcard pattern matching with support for '?' and '*'. '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). The function prototype should be: bool isMatch(const char *s, const char *p) Some examples: isMatch(\"aa\",\"a\") → false isMatch(\"aa\",\"aa\") → true isMatch(\"aaa\",\"aa\") → false isMatch(\"aa\", \"*\") → true isMatch(\"aa\", \"a*\") → true isMatch(\"ab\", \"?*\") → true isMatch(\"aab\", \"c*a*b\") → false 解法(1)：O(n*m) 当 p[jj] == ‘*’ 时，dp[i][j] = dp[i][j-1] | dp[i-1][j]. class Solution { public: bool isMatch(string s, string p) { int n = s.size(), m = p.size(); vector dp_pre(m+1, false); dp_pre[0] = true; for(int j = 1; j dp_cur(m+1, false); for(int j = 1; j 解法(2)：更优的解法。 遇到*的处理：用pstar记下*在串p的位置， 用spos记下对应串s的位置。指针j++。 失配时，指针i, j 回退到spos, pstar的位置重新尝试匹配。即 i = ++spos，j = pstar+1. class Solution { public: bool isMatch(string s, string p) { int n = s.size(), m = p.size(); int i = 0, j = 0, pstar = -1, spos; while(i "},"solutions/46&47. Permutations & Permutations II.html":{"url":"solutions/46&47. Permutations & Permutations II.html","title":"LeetCode 46&47. Permutations & Permutations II","keywords":"","body":"LeetCode 46. Permutations Given a collection of distinct numbers, return all possible permutations. For example, [1,2,3] have the following permutations: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 无重复元素的全排列。 解法一：递归 (非字典序输出) class Solution { public: vector> rst; void solve(int from, vector& nums){ if(from == nums.size()){ rst.push_back(nums); return; } for(int i = from; i > permute(vector& nums) { solve(0, nums); return rst; } }; LeetCode 47. Permutations II Given a collection of numbers that might contain duplicates, return all possible unique permutations. For example, [1,1,2] have the following unique permutations: [ [1,1,2], [1,2,1], [2,1,1] ] 有重复元素的全排列。 解法1: 对最终结果用 set 过滤. 最后 return vector>(set.begin(), set.end()); 解法2: 仅靠以下两个条件是无法完全去重的: if(i != from && nums[i] == nums[from]) continue; if(i > from && nums[i] == nums[i-1]) continue; 对每次循环，而是考虑用unordered_set来去重，即如果该数值已经swap过，表明不需要再swap. (非字典序输出) class Solution { public: vector> rst; void solve(int from, vector& nums){ if(from == nums.size()){ rst.push_back(nums); return; } unordered_set set; for(int i = from; i > permuteUnique(vector& nums) { solve(0, nums); return rst; } }; 解法3: next_permutation (字典序输出) class Solution { public: bool next_permutation(vector& nums){ int n = nums.size(); if(n == 1) return false; int i = n-2; while(i >= 0 && nums[i] >= nums[i+1]) i--; if(i nums[i]) j++; swap(nums[i], nums[--j]); reverse(nums.begin()+i+1, nums.end()); return true; } vector> permuteUnique(vector& nums) { vector > rst; sort(nums.begin(), nums.end()); rst.push_back(nums); while(true){ vector vec(rst.back()); if(next_permutation(vec)){ rst.push_back(vec); }else break; } return rst; } }; "},"solutions/146. LRU Cache.html":{"url":"solutions/146. LRU Cache.html","title":"LeetCode 146. LRU Cache","keywords":"","body":"LeetCode 146. LRU Cache Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. Follow up: Could you do both operations in O(1) time complexity? Example: LRUCache cache = new LRUCache( 2 /* capacity */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // returns 1 cache.put(3, 3); // evicts key 2 cache.get(2); // returns -1 (not found) cache.put(4, 4); // evicts key 1 cache.get(1); // returns -1 (not found) cache.get(3); // returns 3 cache.get(4); // returns 4 利用双向链表实现O(1)的删除、插入元素，用hashmap来实现O(1)的查找。 list即是STL中的双向链表结构。 class LRUCache { public: LRUCache(int capacity) { m_capacity = capacity; } int get(int key) { auto it = m_map.find(key); if(it == m_map.end()) return -1; int val = it->second->second; m_list.erase(it->second); m_list.push_front(make_pair(key, val)); m_map[key] = m_list.begin(); return val; } void put(int key, int value) { auto it = m_map.find(key); if(it == m_map.end()){ if(m_capacity == m_list.size()){ m_map.erase(m_map.find(m_list.back().first)); m_list.pop_back(); } m_list.push_front(make_pair(key, value)); m_map[key] = m_list.begin(); }else{ m_list.erase(it->second); m_list.push_front(make_pair(key, value)); m_map[key] = m_list.begin(); } } private: int m_capacity; list> m_list; // unordered_map>::iterator> m_map; }; "}}