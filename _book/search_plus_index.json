{"./":{"url":"./","title":"Introduction","keywords":"","body":"gitbook-leetcode-solutions GitBook for LeetCode solutions Setup $ git clone https://github.com/lszero/gitbook-leetcode-solutions.git $ cd gitbook-leetcode-solutions $ gitbook serve "},"solutions/47-Permutations II.html":{"url":"solutions/47-Permutations II.html","title":"LeetCode 47. Permutations II","keywords":"","body":"47. Permutations II Given a collection of numbers that might contain duplicates, return all possible unique permutations. For example, [1,1,2] have the following unique permutations: [ [1,1,2], [1,2,1], [2,1,1] ] 有重复元素的全排列。 [ [1,1,2], [1,2,1], [2,1,1] ] 仅加该条件是无法完全去重的: if(i != from && nums[i] == nums[from]) continue; 解法1: 用 set. 最后 vector>(set.begin(), set.end()); class Solution { public: vector> rst; void solve(int from, vector& nums){ int n = nums.size(); if(from == n){ rst.push_back(nums); return; } for(int i = from; i from && nums[i] == nums[i-1]) continue; swap(nums[from], nums[i]); solve(from+1, nums); swap(nums[from], nums[i]); } } vector> permuteUnique(vector& nums) { int n = nums.size(); sort(nums.begin(), nums.end()); solve(0, nums); return rst; } }; "}}