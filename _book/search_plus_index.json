{"./":{"url":"./","title":"Introduction","keywords":"","body":"gitbook-leetcode-solutions GitBook for LeetCode solutions. Demo: http://lszero.com/leetcode/ GitHub: https://github.com/lszero/gitbook-leetcode-solutions Setup $ npm install gitbook-cli -g $ git clone https://github.com/lszero/gitbook-leetcode-solutions.git $ cd gitbook-leetcode-solutions $ gitbook serve "},"solutions/146. LRU Cache.html":{"url":"solutions/146. LRU Cache.html","title":"LeetCode 146. LRU Cache","keywords":"","body":"LeetCode 146. LRU Cache Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. Follow up: Could you do both operations in O(1) time complexity? Example: LRUCache cache = new LRUCache( 2 /* capacity */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // returns 1 cache.put(3, 3); // evicts key 2 cache.get(2); // returns -1 (not found) cache.put(4, 4); // evicts key 1 cache.get(1); // returns -1 (not found) cache.get(3); // returns 3 cache.get(4); // returns 4 利用双向链表实现O(1)的删除、插入元素，用hashmap来实现O(1)的查找。 list即是STL中的双向链表结构。 class LRUCache { public: LRUCache(int capacity) { m_capacity = capacity; } int get(int key) { auto it = m_map.find(key); if(it == m_map.end()) return -1; int val = it->second->second; m_list.erase(it->second); m_list.push_front(make_pair(key, val)); m_map[key] = m_list.begin(); return val; } void put(int key, int value) { auto it = m_map.find(key); if(it == m_map.end()){ if(m_capacity == m_list.size()){ m_map.erase(m_map.find(m_list.back().first)); m_list.pop_back(); } m_list.push_front(make_pair(key, value)); m_map[key] = m_list.begin(); }else{ m_list.erase(it->second); m_list.push_front(make_pair(key, value)); m_map[key] = m_list.begin(); } } private: int m_capacity; list> m_list; // unordered_map>::iterator> m_map; }; "}}