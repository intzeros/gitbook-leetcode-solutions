{"./":{"url":"./","title":"Introduction","keywords":"","body":"gitbook-leetcode-solutions GitBook for LeetCode solutions. Demo: http://lszero.com/leetcode/ GitHub: https://github.com/lszero/gitbook-leetcode-solutions Setup $ npm install gitbook-cli -g $ git clone https://github.com/lszero/gitbook-leetcode-solutions.git $ cd gitbook-leetcode-solutions $ gitbook serve "},"favorite_list.html":{"url":"favorite_list.html","title":"Favorite list","keywords":"","body":"Favorite Problems 多做几遍： LeetCode 4. Median of Two Sorted Arrays LeetCode 32. Longest Valid Parentheses LeetCode 39&40&216&377. Combination Sum LeetCode 44. Wildcard Matching LeetCode 46&47. Permutations LeetCode 146. LRU Cache LeetCode 148. Sort List LeetCode 322&518. Coin Change 值得二刷： LeetCode 3. Longest Substring Without Repeating Characters LeetCode 4. Median of Two Sorted Arrays LeetCode 5. Longest Palindromic Substring LeetCode 6. ZigZag Conversion LeetCode 9. Palindrome Number LeetCode 11. Container With Most Water LeetCode 12&13. Integer to Roman & Roman to Integer LeetCode 15. 3Sum LeetCode 17. Letter Combinations of a Phone Number LeetCode 22. Generate Parentheses LeetCode 23. Merge k Sorted Lists LeetCode 25. Reverse Nodes in k-Group LeetCode 26&80. Remove Duplicates from Sorted Array LeetCode 28. Implement strStr() LeetCode 29. Divide Two Integers LeetCode 30. Substring with Concatenation of All Words LeetCode 31. Next Permutation LeetCode 33&81. Search in Rotated Sorted Array LeetCode 34. Search for a Range LeetCode 36. Valid Sudoku LeetCode 37. Sudoku Solver LeetCode 41. First Missing Positive LeetCode 71. Simplify Path ​ "},"solutions/1. Two Sum.html":{"url":"solutions/1. Two Sum.html","title":"LeetCode 1. Two Sum","keywords":"","body":"LeetCode 1. Two Sum Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 解法一：O(nlogn)。先排序，再二分查找，或者从两头往中间查找的方式。 因为题目要求返回的是下标，除了用struct Node记录下标再排序之外，可以新开一个数组记录下标，然后利用lambda表达式对该数组进行排序，代码更简洁一些。 class Solution { public: vector twoSum(vector& nums, int target) { int n = nums.size(); vector idx(n); for(int i = 0; i rst; while(le target) ri--; else le++; } return rst; } }; 解法二：O(n)。hash查找。为了避免重复，用边插入边查找的方式。 class Solution { public: vector twoSum(vector& nums, int target) { int n = nums.size(); unordered_map hashMap; // vector rst; for(int i = 0; i "},"solutions/2. Add Two Numbers.html":{"url":"solutions/2. Add Two Numbers.html","title":"LeetCode 2. Add Two Numbers","keywords":"","body":"LeetCode 2. Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* p1 = l1, *p2 = l2; ListNode* H = new ListNode(0), *tail = H; int c = 0; while(p1 || p2 || c){ if(p1) c += p1->val; if(p2) c += p2->val; ListNode *q = new ListNode(c % 10); tail->next = q; tail = q; if(c >= 10) c = 1; else c = 0; if(p1) p1 = p1->next; if(p2) p2 = p2->next; } return H->next; } }; "},"solutions/3. Longest Substring Without Repeating Characters.html":{"url":"solutions/3. Longest Substring Without Repeating Characters.html","title":"LeetCode 3. Longest Substring Without Repeating Characters","keywords":"","body":"LeetCode 3. Longest Substring Without Repeating Characters Given a string, find the length of the longest substring without repeating characters. Examples: Given \"abcabcbb\", the answer is \"abc\", which the length is 3. Given \"bbbbb\", the answer is \"b\", with the length of 1. Given \"pwwkew\", the answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequenceand not a substring. （注意输入字符不止26个字母) class Solution { public: int lengthOfLongestSubstring(string s) { int n = s.size(); vector used(256, false); int ans = 0, len = 0; for(int i = 0; i "},"solutions/4. Median of Two Sorted Arrays.html":{"url":"solutions/4. Median of Two Sorted Arrays.html","title":"LeetCode 4. Median of Two Sorted Arrays","keywords":"","body":"LeetCode 4. Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1: nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 O(log(min(N, M))). 思路： 将原问题转化为求第k大的数。 易想到分治算法。首先设想k比较小时（如取1、2），我们会怎么求？故分治策略跟k有关。 分治思路： 从已排好序的数组1中取前k1个数，数组2中取前k2个数（k1+k2=k. 为了达到更好的分治效果, 取k1 = k/2）。 （1）若nums1[k1] nums2[k2]，同（1）。 （3）若nums1[k1] == nums2[k2]，nums1[k1] 即为第k大的数。 总结起来就是, 每次扔掉 k/2个最大的数(若求 k-th 大), 然后更新 k 的值. int findKth(int nums1[], int n1, int nums2[], int n2, int k){ //always assume that n1 is equal or smaller than n2 if(n1 > n2) return findKth(nums2, n2, nums1, n1, k); if(n1 == 0) return nums2[k-1]; if(k == 1) return min(nums1[0], nums2[0]); // divide k into two parts int k1 = min(k/2, n1); int k2 = k-k1; if(nums1[k1-1] nums2[k2-1]){ return findKth(nums1, n1, nums2+k2, n2-k2, k-k2); }else{ return nums1[k1-1]; } } double findMedianSortedArrays(int nums1[], int n1, int nums2[], int n2) { if((n1+n2) & 1){ return findKth(nums1, n1, nums2, n2, (n1+n2)/2 + 1); }else{ return (findKth(nums1, n1, nums2, n2, (n1+n2)/2) + findKth(nums1, n1, nums2, n2, (n1+n2)/2 + 1)) / 2.0; } } "},"solutions/5. Longest Palindromic Substring.html":{"url":"solutions/5. Longest Palindromic Substring.html","title":"LeetCode 5. Longest Palindromic Substring","keywords":"","body":"LeetCode 5. Longest Palindromic Substring Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example: Input: \"babad\" Output: \"bab\" Note: \"aba\" is also a valid answer. Example: Input: \"cbbd\" Output: \"bb\" DP: isp[i][j]: 子串S(i, j)是否为回文串。 若子串S(i, j)是回文串，并且字符s[i-1] == s[j+1], 则子串S(i-1, j+1)也是回文串。 第二层 for 循环为逆推. class Solution { public: string longestPalindrome(string s) { int n = s.size(); vector> isp(n, vector(n, false)); int start = 0, len = 0; for(int i = 0; i = 0; j--){ if(s[i] == s[j] && (i-j len) len = i-j+1, start = j; } } } return s.substr(start, len); } }; "},"solutions/6. ZigZag Conversion.html":{"url":"solutions/6. ZigZag Conversion.html","title":"LeetCode 6. ZigZag Conversion","keywords":"","body":"LeetCode 6. ZigZag Conversion The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H N A P L S I I G Y I R And then read line by line: \"PAHNAPLSIIGYIR\" Write the code that will take a string and make this conversion given a number of rows: string convert(string text, int nRows); convert(\"PAYPALISHIRING\", 3) should return \"PAHNAPLSIIGYIR\" . 一开始我用的是周期性。T = numRows*2-2, 另外中间行还要多加一个s[idx + T-2*r]。 class Solution { public: string convert(string s, int numRows) { if(numRows == 1) return s; int n = s.size(); int T = (numRows 看到 leetcode discuss一种更简单的解法。 把每一行的遍历结果首先放到 vector 中。顺序遍历字符串s，将当前字符添加到对应行的vec[i]中。 class Solution { public: string convert(string s, int numRows) { vector vec(numRows); int k = 0, n = s.size(); while(k = 1; i--){ //斜向上方向 vec[i] += s[k++]; } } string rst; for(int i = 0; i "},"solutions/7. Reverse Integer.html":{"url":"solutions/7. Reverse Integer.html","title":"LeetCode 7. Reverse Integer","keywords":"","body":"LeetCode 7. Reverse Integer Reverse digits of an integer. Example1: x = 123, return 321 Example2: x = -123, return -321 注意细节： (1) 前置0 (2) 超出int范围（输出0） class Solution { public: int reverse(int x) { long long rst = 0; while(x){ rst = rst*10 + x%10; x /= 10; } int MAX = 0x7fffffff, MIN = 0x80000000; if(rst > MAX || rst "},"solutions/8. String to Integer-atoi.html":{"url":"solutions/8. String to Integer-atoi.html","title":"LeetCode 8. String to Integer (atoi)","keywords":"","body":"LeetCode 8. String to Integer (atoi) Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Update (2015-02-10): The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition. Four cases need to pay attention： whitespaces sign overflow invalid input class Solution { public: int myAtoi(string str) { long long x = 0; int n = str.size(), i = 0, sign = 1; while(i = '0' && str[i] MAX) return MAX; else if(sign == 0 && -x "},"solutions/9. Palindrome Number.html":{"url":"solutions/9. Palindrome Number.html","title":"LeetCode 9. Palindrome Number","keywords":"","body":"LeetCode 9. Palindrome Number Determine whether an integer is a palindrome. Do this without extra space. 最简单的方式：将后半段转置之后，再跟全半段比较。 将数字截取成两段的条件为：while(x > y). 有一点要注意：(x != 0 && x%10 == 0)这种情况需要特殊判断一下，比如20这个数字。 class Solution { public: bool isPalindrome(int x) { if(x y){ y = y*10 + x%10; x /= 10; } return x == y || y/10 == x; } }; "},"solutions/10. Regular Expression Matching.html":{"url":"solutions/10. Regular Expression Matching.html","title":"LeetCode 10. Regular Expression Matching","keywords":"","body":"LeetCode 10. Regular Expression Matching Implement regular expression matching with support for '.' and '*'. '.' Matches any single character. '*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). The function prototype should be: bool isMatch(const char *s, const char *p) Some examples: isMatch(\"aa\",\"a\") → false isMatch(\"aa\",\"aa\") → true isMatch(\"aaa\",\"aa\") → false isMatch(\"aa\", \"a*\") → true isMatch(\"aa\", \".*\") → true isMatch(\"ab\", \".*\") → true isMatch(\"aab\", \"c*a*b\") → true 不同于LeetCode 44. Wildcard Matching，这里的*号表示其前一个字符可以出现0次到多次。 DP, O(n*m)的解法。 注意 s=””, p=”.”时 -> false. class Solution { public: bool isMatch(string s, string p) { int n = s.size(), m = p.size(); vector> dp(n+1, vector(m+1, false)); dp[0][0] = true; for(int j = 1; j "},"solutions/11. Container With Most Water.html":{"url":"solutions/11. Container With Most Water.html","title":"LeetCode 11. Container With Most Water","keywords":"","body":"LeetCode 11. Container With Most Water Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. 贪心。le, ri指针从两端往中间走，并且height更短的那条先走。 class Solution { public: int maxArea(vector& height) { int le = 0, ri = height.size()-1, ans = 0; while(le ans) ans = area; if(height[le] "},"solutions/12&13. Integer to Roman & Roman to Integer.html":{"url":"solutions/12&13. Integer to Roman & Roman to Integer.html","title":"LeetCode 12&13. Integer to Roman & Roman to Integer","keywords":"","body":"LeetCode 12. Integer to Roman Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. 罗马数字采用七个罗马字母作数字，即 I（1）、V（5）、X（10）、L（50）、C（100）、D（500）、M（1000）。记数的方法： （1）相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ=3； （2）小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数，如 Ⅷ=8、Ⅻ=12； （3）小的数字（限于 Ⅰ、X 和 C）在大的数字的左边，所表示的数等于大数减小数得到的数，如 Ⅳ=4、Ⅸ=9. 不过像99，不能表示为IC (100-1)，而是XCIX (100-10+10-1). 例子： 299 499 599 899 999 CC XCIX CD XCIX D XCIX DCCC XCIX CM XCIX 200+99 (500-100)+99 500+99 (500+300)+99 (1000-100)+99 class Solution { public: string C[8] = {\"\", \"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"}; int D[8] = {5000, 1000, 500, 100, 50, 10, 5, 1 }; string intToRoman(int num) { string ans = \"\"; for(int i = 1; i 我写的解法需要将40和90分开处理，所以用了(i&1)。 网上看到更简的解法，不同于上面的C[]，D[]： string C[13] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}; int D[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 }; class Solution { public: string C[13] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}; int D[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 }; string intToRoman(int num) { string ans = \"\"; for(int i = 0; i = D[i]){ num -= D[i]; ans += C[i]; } } return ans; } }; LeetCode 13. Roman to Integer Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. class Solution { public: int getVal(char c){ switch(c){ case 'M': return 1000; case 'D': return 500; case 'C': return 100; case 'L': return 50; case 'X': return 10; case 'V': return 5; case 'I': return 1; } return 0; } int romanToInt(string s) { int n = s.size(); int ans = 0, i = 0; while(i "},"solutions/14. Longest Common Prefix.html":{"url":"solutions/14. Longest Common Prefix.html","title":"LeetCode 14. Longest Common Prefix","keywords":"","body":"LeetCode 14. Longest Common Prefix Write a function to find the longest common prefix string amongst an array of strings. class Solution { public: string longestCommonPrefix(vector& strs) { if(strs.size() == 0) return \"\"; for(int k = 0; k "},"solutions/15. 3Sum.html":{"url":"solutions/15. 3Sum.html","title":"LeetCode 15. 3Sum","keywords":"","body":"LeetCode 15. 3Sum Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. For example, given array S = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] 将 -1×nums[i] 作为 twoSum problem 的 target，从数组nums[i+1, …, n)的两端往中间查找。 class Solution { public: vector> threeSum(vector& nums) { int n = nums.size(); sort(nums.begin(), nums.end()); vector> rst; for(int i = 0; i 0 && nums[i] == nums[i-1]) continue; //去重 int target = -nums[i]; int le = i+1, ri = n-1; //twoSum的查找范围为[i+1, n) while(le vec; vec.push_back(nums[le]); vec.push_back(nums[ri]); vec.push_back(nums[i]); rst.push_back(vec); while(le "},"solutions/16. 3Sum Closest.html":{"url":"solutions/16. 3Sum Closest.html","title":"LeetCode 16. 3Sum Closest","keywords":"","body":"LeetCode 16. 3Sum Closest Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. For example, given array S = {-1 2 1 -4}, and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 稍微在 3Sum 改一下就好了。 class Solution { public: int threeSumClosest(vector& nums, int target) { sort(nums.begin(), nums.end()); int n = nums.size(), ans, min = 0x3f3f3f3f; for(int i = 0; i 0 && nums[i] == nums[i-1]) continue; int le = i+1, ri = n-1; while(le "},"solutions/17. Letter Combinations of a Phone Number.html":{"url":"solutions/17. Letter Combinations of a Phone Number.html","title":"LeetCode 17. Letter Combinations of a Phone Number","keywords":"","body":"LeetCode 17. Letter Combinations of a Phone Number Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Input:Digit string \"23\" Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. 非递归的实现方式： class Solution { public: string symbols[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; vector letterCombinations(string digits) { int n = digits.size(); vector rst; if(n == 0) return rst; rst.push_back(\"\"); for(int i = 0; i "},"solutions/18. 4Sum.html":{"url":"solutions/18. 4Sum.html","title":"LeetCode 18. 4Sum","keywords":"","body":"LeetCode 18. 4Sum Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is: [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] O(n^3) : class Solution { public: vector> fourSum(vector& nums, int target) { sort(nums.begin(), nums.end()); int n = nums.size(); vector> rst; for(int i = 0; i 0 && nums[i] == nums[i-1]) continue; for(int j = i+1; j i+1 && nums[j] == nums[j-1]) continue; //注意这里的 j > i+1, 而非 j > 0 int le = j+1, ri = n-1; while(le vec; vec.push_back(nums[i]); vec.push_back(nums[j]); vec.push_back(nums[le]); vec.push_back(nums[ri]); rst.push_back(vec); while(le "},"solutions/19. Remove Nth Node From End of List.html":{"url":"solutions/19. Remove Nth Node From End of List.html","title":"LeetCode 19. Remove Nth Node From End of List","keywords":"","body":"LeetCode 19. Remove Nth Node From End of List Given a linked list, remove the nth node from the end of list and return its head. For example, Given linked list: 1->2->3->4->5, and n = 2. After removing the second node from the end, the linked list becomes 1->2->3->5. Note: Given n will always be valid. Try to do this in one pass. class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *H = new ListNode(0); H->next = head; ListNode *p = H, *q = H; while(n--){ p = p->next; } p = p->next; while(p){ p = p->next; q = q->next; } p = q->next; q->next = q->next->next; delete p; return H->next; } }; "},"solutions/20. Valid Parentheses.html":{"url":"solutions/20. Valid Parentheses.html","title":"LeetCode 20. Valid Parentheses","keywords":"","body":"LeetCode 20. Valid Parentheses Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. The brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not. class Solution { public: bool isValid(string s) { stack stk; int n = s.size(); for(int i = 0; i "},"solutions/21. Merge Two Sorted Lists.html":{"url":"solutions/21. Merge Two Sorted Lists.html","title":"LeetCode 21. Merge Two Sorted Lists","keywords":"","body":"LeetCode 21. Merge Two Sorted Lists Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode *H = new ListNode(0), *tail = H; while(l1 && l2){ if(l1->val val){ tail->next = l1; tail = l1; l1 = l1->next; }else{ tail->next = l2; tail = l2; l2 = l2->next; } } if(l1) tail->next = l1; if(l2) tail->next = l2; return H->next; } }; "},"solutions/22. Generate Parentheses.html":{"url":"solutions/22. Generate Parentheses.html","title":"LeetCode 22. Generate Parentheses","keywords":"","body":"LeetCode 22. Generate Parentheses Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: [ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] 解法1： 第一个字符必然是左括号”(“，其对应的右括号”)”将剩余的字符串分为两部分。 class Solution { public: vector > dp; Solution() : dp(50) {} vector generateParenthesis(int n) { vector rst; if(n == 0) return rst; if(n == 1){ rst.push_back(\"()\"); return rst; } if(dp[n].size() > 0) return dp[n]; for(int i = 0; i rst1 = generateParenthesis(i); vector rst2 = generateParenthesis(n-i-1); if(rst1.size() == 0) rst1.push_back(\"\"); if(rst2.size() == 0) rst2.push_back(\"\"); for(int j = 0; j 解法2： leftNum, rightNum分别表示当前解的左、右括号数。 输出”)”时要多加一个条件：rightNum class Solution { public: void solve(string sol, int leftNum, int rightNum, int n, vector& rst){ if(leftNum == n && rightNum == n){ rst.push_back(sol); return; } if(leftNum rightNum){ solve(sol+\")\", leftNum, rightNum+1, n, rst); } } vector generateParenthesis(int n) { vector rst; solve(\"\", 0, 0, n, rst); return rst; } }; "},"solutions/23. Merge k Sorted Lists.html":{"url":"solutions/23. Merge k Sorted Lists.html","title":"LeetCode 23. Merge k Sorted Lists","keywords":"","body":"LeetCode 23. Merge k Sorted Lists Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 注意优先队列的自定义排序方式。 struct cmp{ bool operator()(const ListNode* p, const ListNode* q){ return p->val > q->val; // 小顶堆 } }; class Solution { public: ListNode* mergeKLists(vector& lists) { ListNode *H = new ListNode(0), *tail = H; priority_queue, cmp> Q; for(int i = 0; i next = p; tail = p; p = p->next; if(p) Q.push(p); } return H->next; } }; "},"solutions/24. Swap Nodes in Pairs.html":{"url":"solutions/24. Swap Nodes in Pairs.html","title":"LeetCode 24. Swap Nodes in Pairs","keywords":"","body":"LeetCode 24. Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head. For example, Given 1->2->3->4, you should return the list as 2->1->4->3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode *H = new ListNode(0), *pre = H, *p, *q; H->next = head; while(pre->next && pre->next->next){ p = pre->next; q = pre->next->next; p->next = q->next; pre->next = q; q->next = p; pre = p; } return H->next; } }; "},"solutions/25. Reverse Nodes in k-Group.html":{"url":"solutions/25. Reverse Nodes in k-Group.html","title":"LeetCode 25. Reverse Nodes in k-Group","keywords":"","body":"LeetCode 25. Reverse Nodes in k-Group Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. You may not alter the values in the nodes, only nodes itself may be changed. Only constant memory is allowed. For example, Given this linked list: 1->2->3->4->5 For k = 2, you should return: 2->1->4->3->5 For k = 3, you should return: 3->2->1->4->5 class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { int n = 0; ListNode *p = head; while(p){ n++; p = p->next; } ListNode *H = new ListNode(0), *h = H, *tail = H; while(n >= k){ tail = head; for(int i = 0; i next; head->next = h->next; h->next = head; head = p; } h = tail; n -= k; } if(head) h->next = head; return H->next; } }; "},"solutions/26&80. Remove Duplicates from Sorted Array.html":{"url":"solutions/26&80. Remove Duplicates from Sorted Array.html","title":"LeetCode 26&80. Remove Duplicates from Sorted Array","keywords":"","body":"LeetCode 26. Remove Duplicates from Sorted Array Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example, Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length. class Solution { public: int removeDuplicates(vector& nums) { int k = 0; for(int i = 0; i 0 && nums[i] == nums[i-1]) k++; else nums[i-k] = nums[i]; } return nums.size() - k; } }; LeetCode 80. Remove Duplicates from Sorted Array II Follow up for \"Remove Duplicates\": What if duplicates are allowed at most twice? For example, Given sorted array nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn't matter what you leave beyond the new length. 如果直接将上述代码改为 if(i >= 2 && nums[i] == nums[i-2]) k++; 是不可行的. 因为在判断 nums[i-2]时, nums[i-2]可能已经被修改过了. 比如 [1,1,1,2,2,3], 得到错误结果 [1,1,2,3]. 正确的是判断: nums[i] == nums[i-2-k]. class Solution { public: int removeDuplicates(vector& nums) { int k = 0; for(int i = 0; i = 2 && nums[i] == nums[i-2-k]) k++; else nums[i-k] = nums[i]; } return nums.size()-k; } }; "},"solutions/27. Remove Element.html":{"url":"solutions/27. Remove Element.html","title":"LeetCode 27. Remove Element","keywords":"","body":"LeetCode 27. Remove Element Given an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn't matter what you leave beyond the new length. Example: Given input array nums = [3,2,2,3], val = 3 Your function should return length = 2, with the first two elements of nums being 2. class Solution { public: int removeElement(vector& nums, int val) { int k = 0; for(int i = 0; i "},"solutions/28. Implement strStr.html":{"url":"solutions/28. Implement strStr.html","title":"LeetCode 28. Implement strStr()","keywords":"","body":"LeetCode 28. Implement strStr() Implement strStr(). Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. KMP. class Solution { public: vector get_next(string t){ int m = t.size(); vector next(m); if(m == 0) return next; int i = 0, j = -1; next[0] = -1; while(i next = get_next(t); int i = 0, j = 0; while(i "},"solutions/29. Divide Two Integers.html":{"url":"solutions/29. Divide Two Integers.html","title":"LeetCode 29. Divide Two Integers","keywords":"","body":"LeetCode 29. Divide Two Integers Divide two integers without using multiplication, division and mod operator. If it is overflow, return MAX_INT. 除了注意边界值之外(-2147483648 / -1)，按O(n)解会TL. O(logn)的解法： 如 计算：37/7. 37 = 5*7 + 2 = (2^2 + 1) * 7 + 2 = 2^2 * 7 + 1 * 7 + 2 . 思路就是，将除数进行左移乘2，直到最靠近被除数但不大于被除数为止，设为c。然后每次尝试用被除数减去c，并且c右移除2。直到c为0. class Solution { public: int divide(int dividend, int divisor) { int MAX_INT = 0x7fffffff; long long a = abs((long long)dividend); long long b = abs((long long)divisor); long long c = 1; while(a >= b){ b >= 1; b >>= 1; if(a >= b){ a -= b; ans += c; } } if(dividend > 0 && divisor 0) ans = -ans; if(ans > MAX_INT) return MAX_INT; return ans; } }; "},"solutions/30. Substring with Concatenation of All Words.html":{"url":"solutions/30. Substring with Concatenation of All Words.html","title":"LeetCode 30. Substring with Concatenation of All Words","keywords":"","body":"LeetCode 30. Substring with Concatenation of All Words You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. For example, given: s: \"barfoothefoobarman\" words: [\"foo\", \"bar\"] You should return the indices: [0,9]. (order does not matter). 用的是最简单的解法，O(N*M). class Solution { public: vector findSubstring(string s, vector& words) { int n = s.size(), m = words.size(), len = words[0].size(); unordered_map counts; for(int i = 0; i rst; unordered_map counting; for(int i = 0; i counts[key]) break; } if(j == m) rst.push_back(i); } return rst; } }; "},"solutions/31. Next Permutation.html":{"url":"solutions/31. Next Permutation.html","title":"LeetCode 31. Next Permutation","keywords":"","body":"LeetCode 31. Next Permutation Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place, do not allocate extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1 找到序列末尾呈下降趋势的子序列, 假如为 nums[i, …, n). 再在该子序列里找一个最靠近nums[i-1]且比它大的数nums[j]，swap(nums[i], nums[j])，最后reverse数组。 class Solution { public: void nextPermutation(vector& nums) { int n = nums.size(), i = n-1; while(i > 0 && nums[i-1] >= nums[i]) i--; if(i == 0){ reverse(nums.begin(), nums.end()); return; } int j = n-1; while(j >= i && nums[j] "},"solutions/32. Longest Valid Parentheses.html":{"url":"solutions/32. Longest Valid Parentheses.html","title":"LeetCode 32. Longest Valid Parentheses","keywords":"","body":"LeetCode 32. Longest Valid Parentheses Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. For \"(()\", the longest valid parentheses substring is \"()\", which has length = 2. Another example is \")()())\", where the longest valid parentheses substring is \"()()\", which has length = 4. 一开始的想法是用数组left[]记录当前右括号’)’所对应'(‘的位置。然后根据left[]不断往前索引，统计匹配个数。这样复杂度比较高。 O(n)的解法： dp[i]表示一定选当前右括号’)’的最长括号匹配数. class Solution { public: int longestValidParentheses(string s) { int n = s.size(), ans = 0; vector dp(n, 0); for(int i = 1; i = 0 && s[k-1] == '('){ dp[i] = dp[i-1] + 2; if(k-2 >= 0 && s[k-2] == ')') dp[i] += dp[k-2]; } if(ans "},"solutions/33&81. Search in Rotated Sorted Array.html":{"url":"solutions/33&81. Search in Rotated Sorted Array.html","title":"LeetCode 33&81. Search in Rotated Sorted Array","keywords":"","body":"LeetCode 33. Search in Rotated Sorted Array Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. 无重复元素。 主要思想是，先找出递增的半段。 class Solution { public: int search(vector& nums, int target) { int le = 0, ri = nums.size()-1, mid; while(le >1; if(nums[mid] == target) return mid; if(le == mid || nums[le] LeetCode 81. Search in Rotated Sorted Array II Follow up for \"Search in Rotated Sorted Array\": What if duplicates are allowed? Would this affect the run-time complexity? How and why? Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Write a function to determine if a given target is in the array. The array may contain duplicates. 有重复元素。 考虑一种特殊情况，如以下测试用例，如何区分出递增的半段序列. nums=[1,3,1,1,1], target=3 对 nums[le] == nums[mid] && nums[mid] == nums[ri] 这种情况, le++, ri–. class Solution { public: bool search(vector& nums, int target) { int le = 0, ri = nums.size()-1, mid; while(le >1; if(nums[mid] == target) return true; if(nums[le] == nums[mid] && nums[mid] == nums[ri]){ le++, ri--; }else if(nums[le] "},"solutions/34. Search for a Range.html":{"url":"solutions/34. Search for a Range.html","title":"LeetCode 34. Search for a Range","keywords":"","body":"LeetCode 34. Search for a Range Given an array of integers sorted in ascending order, find the starting and ending position of a given target value. Your algorithm's runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. For example, Given [5, 7, 7, 8, 8, 10] and target value 8, return [3, 4]. C++ STL中的: lower_bound: Returns an iterator pointing to the first element in the range [first, last) that is not less than (i.e. greater or equal to) value, or last if no such element is found. upper_bound: Returns an iterator pointing to the first element in the range [first, last) that is greater than value, or last if no such element is found. class Solution { public: vector searchRange(vector& nums, int target) { vector rst(2, -1); auto it1 = lower_bound(nums.begin(), nums.end(), target); if(it1 == nums.end() || *it1 != target) return rst; auto it2 = upper_bound(nums.begin(), nums.end(), target); rst[0] = it1 - nums.begin(); rst[1] = it2 - nums.begin() - 1; return rst; } }; 只用lower_bound的实现方式： it2 = lower_bound(nums.begin(), nums.end(), target+1) class Solution { public: vector searchRange(vector& nums, int target) { vector rst(2, -1); auto it1 = lower_bound(nums.begin(), nums.end(), target); if(it1 == nums.end() || *it1 != target) return rst; auto it2 = lower_bound(nums.begin(), nums.end(), target+1); rst[0] = it1 - nums.begin(); rst[1] = it2 - nums.begin() - 1; return rst; } }; 自己实现find： find1() 表示求第一个target的位置，若找不到则返回-1. find2() 表示求最后一个target的位置，若找不到则返回-1. 主要注意的点： 当nums[mid]==target时的处理。 return le or ri. 返回-1的处理。 class Solution { public: int find1(vector& nums, int target){ int le = 0, ri = nums.size()-1, mid; while(le >1; if(target & nums, int target){ int le = 0, ri = nums.size()-1, mid; while(le >1; if(target >= nums[mid]) le = mid+1; else ri = mid-1; } if(ri >= 0 && nums[ri] == target) return ri; return -1; } vector searchRange(vector& nums, int target) { vector rst; rst.push_back(find1(nums, target)); rst.push_back(find2(nums, target)); return rst; } }; "},"solutions/35. Search Insert Position.html":{"url":"solutions/35. Search Insert Position.html","title":"LeetCode 35. Search Insert Position","keywords":"","body":"LeetCode 35. Search Insert Position Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Here are few examples. [1,3,5,6], 5 → 2 [1,3,5,6], 2 → 1 [1,3,5,6], 7 → 4 [1,3,5,6], 0 → 0 class Solution { public: int searchInsert(vector& nums, int target) { int le = 0, ri = nums.size()-1, mid; while(le > 1; if(nums[mid] == target){ return mid; }else if(nums[mid] nums[mid]) return mid+1; else return mid; } }; "},"solutions/36. Valid Sudoku.html":{"url":"solutions/36. Valid Sudoku.html","title":"LeetCode 36. Valid Sudoku","keywords":"","body":"LeetCode 36. Valid Sudoku Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. The Sudoku board could be partially filled, where empty cells are filled with the character '.'. A partially filled sudoku which is valid. Note: A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated. 题目并不要求一定要solvable. used1[i][j]表示第i行中，数字j是否被使用过。 used2[i][j]表示第i列中，数字j是否被使用过。 used3[i][j]表示第i个3*3方块中，数字j是否被使用过。 class Solution { public: bool isValidSudoku(vector>& board) { bool used1[9][9] = {false}, used2[9][9] = {false}, used3[9][9] = {false}; for(int row = 0; row "},"solutions/37. Sudoku Solver.html":{"url":"solutions/37. Sudoku Solver.html","title":"LeetCode 37. Sudoku Solver","keywords":"","body":"LeetCode 37. Sudoku Solver Write a program to solve a Sudoku puzzle by filling the empty cells. Empty cells are indicated by the character '.'. You may assume that there will be only one unique solution. A sudoku puzzle... ...and its solution numbers marked in red. DFS class Solution { public: bool check(int x, int y, vector>& board){ for(int j = 0; j >& board){ if(x == 9) return true; if(y == 9) return DFS(x+1, 0, board); if(board[x][y] != '.') return DFS(x, y+1, board); for(int i = 1; i >& board) { DFS(0, 0, board); } }; "},"solutions/38. Count and Say.html":{"url":"solutions/38. Count and Say.html","title":"LeetCode 38. Count and Say","keywords":"","body":"LeetCode 38. Count and Say The count-and-say sequence is the sequence of integers with the first five terms as following: 1. 1 2. 11 3. 21 4. 1211 5. 111221 1 is read off as \"one 1\" or 11. 11 is read off as \"two 1s\" or 21. 21 is read off as \"one 2, then one 1\" or 1211. Given an integer n, generate the nth term of the count-and-say sequence. Note: Each term of the sequence of integers will be represented as a string. Example 1: Input: 1 Output: \"1\" Example 2: Input: 4 Output: \"1211\" 直接按过程求。 class Solution { public: string countAndSay(int n) { n--; string pre = \"1\"; while(n--){ string str = \"\"; int i = 0; while(i "},"solutions/39&40&216&377. Combination Sum.html":{"url":"solutions/39&40&216&377. Combination Sum.html","title":"LeetCode 39&40&216&377. Combination Sum","keywords":"","body":"LeetCode 39. Combination Sum Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. For example, given candidate set [2, 3, 6, 7] and target 7, A solution set is: [ [7], [2, 2, 3] ] 无重复元素，可重复取。 Backtracking. class Solution { public: void solve(int from, vector& candidates, int target, vector& sol, vector>& rst){ if(target == 0){ rst.push_back(sol); return; } for(int i = from; i > combinationSum(vector& candidates, int target) { sort(candidates.begin(), candidates.end()); vector> rst; solve(0, candidates, target, *(new vector()), rst); return rst; } }; LeetCode 40. Combination Sum II Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] 有重复元素，不可重复取。 Backtracking. 跟上题的不同点在： solve(i), solve(i+1). candidates[i] == candidates[i-1], 去重 class Solution { public: void solve(int from, vector& candidates, int target, vector& sol, vector>& rst){ if(target == 0){ rst.push_back(sol); return; } for(int i = from; i from && candidates[i] == candidates[i-1]) continue; //去重 if(target-candidates[i] > combinationSum2(vector& candidates, int target) { sort(candidates.begin(), candidates.end()); vector> rst; solve(0, candidates, target, *(new vector()), rst); return rst; } }; LeetCode 216. Combination Sum III Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Example 1: Input: k = 3, n = 7 Output: [[1,2,4]] Example 2: Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]] class Solution { public: void solve(int from, int k, int target, vector& sol, vector>& rst){ if(target == 0){ if(sol.size() == k) rst.push_back(sol); return; } for(int i = from; i sol.size() + 9 - i + 1) continue; sol.push_back(i); solve(i+1, k, target - i, sol, rst); sol.pop_back(); } } vector> combinationSum3(int k, int n) { vector> rst; solve(1, k, n, *(new vector()), rst); return rst; } }; LeetCode 377. Combination Sum IV Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example: nums = [1, 2, 3] target = 4 The possible combination ways are: (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) Note that different sequences are counted as different combinations. Therefore the output is 7. Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers? 无重复元素，可重复取。 DP. 不同于LeetCode 518. Coin Change 2，该题求得是排序数，即(1, 1, 2), (1, 2, 1), (2, 1, 1)看作不同的解。故第一层for 先循环total, 然后再循环 nums[i]. class Solution { public: int combinationSum4(vector& nums, int target) { vector dp(target+1, 0); dp[0] = 1; for(int total = 0; total "},"solutions/41. First Missing Positive.html":{"url":"solutions/41. First Missing Positive.html","title":"LeetCode 41. First Missing Positive","keywords":"","body":"LeetCode 41. First Missing Positive Given an unsorted integer array, find the first missing positive integer. For example, Given [1,2,0] return 3, and [3,4,-1,1] return 2. Your algorithm should run in O(n) time and uses constant space. 思路： 利用swap，将nums[i]放在数组的第i个位置。 注意的地方：添加判定条件 nums[i] != nums[nums[i]-1]，否则对于测试用例 nums = [1, 1]，会陷入死循环。 class Solution { public: int firstMissingPositive(vector& nums) { int n = nums.size(); for(int i = 0; i = 0 && nums[i]-1 "},"solutions/42&407. Trapping Rain Water.html":{"url":"solutions/42&407. Trapping Rain Water.html","title":"LeetCode 42&407. Trapping Rain Water","keywords":"","body":"LeetCode 42. Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. For example, Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6. 1） 一开始想的解法： 在位置i，该点的储水量 = min(其左边最高的高度，其右边最高的高度) - height[i]. 故用数组maxh1记录从左往右的局部最高的height，数组maxh2记录从右往左的局部最高的height。 class Solution { public: int trap(vector& height) { int n = height.size(); vector maxh1(n+2, 0), maxh2(n+2, 0); for(int i = 1; i = 1; i--){ maxh2[i] = max(height[i-1], maxh2[i+1]); } int ans = 0; for(int i = 1; i height[i-1]) ans += (h - height[i-1]); } return ans; } }; 2）空间复杂度O(1)的解法。将上述两个数组改用变量来实现。 先找到最高的柱子，一分为二。左边部分从左往右遍历，右边部分从右往左遍历。 h记录遍历时遇到的局部最高高度值，则每个位置j 所能容纳的水为：h – height[i]. class Solution { public: int trap(vector& height) { int n = height.size(); int max_idx = 0; for(int i = 0; i h) h = height[i]; ans += h - height[i]; } h = 0; for(int j = n-1; j > max_idx; j--){ if(height[j] > h) h = height[j]; ans += h - height[j]; } return ans; } }; 3）下面这种解法实质和2）是一个意思。 le，ri指针从两端往中间遍历，并且height更矮的先走。 class Solution { public: int trap(vector& height) { int le = 0, ri = height.size()-1, ans = 0, h = 0; while(le h) h = height[le]; ans += h - height[le]; le++; }else{ if(height[ri] > h) h = height[ri]; ans += h - height[ri]; ri--; } } return ans; } }; LeetCode 407. Trapping Rain Water II Given an m x n matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining. Note: Both m and n are less than 110. The height of each unit cell is greater than 0 and is less than 20,000. Example: Given the following 3x6 height map: [ [1,4,3,1,3,2], [3,2,1,3,2,4], [2,3,3,2,3,1] ] Return 4. The above image represents the elevation map [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] before the rain. After the rain, water are trapped between the blocks. The total volume of water trapped is 4. 只靠上下左右四个方向来确定短板高度是行不通的，应该靠围一圈的高度。 如何确定某个点的储水量？首先找该点周围四个方向的短板高度h1，然后以该短板点作为起点，进行BFS，如果该短板点的周围四个方向的短板高度h2 优先队列中，继续取优先队列中的短板高度作为起点，进行BFS. "},"solutions/44. Wildcard Matching.html":{"url":"solutions/44. Wildcard Matching.html","title":"LeetCode 44. Wildcard Matching","keywords":"","body":"LeetCode 44. Wildcard Matching Implement wildcard pattern matching with support for '?' and '*'. '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). The function prototype should be: bool isMatch(const char *s, const char *p) Some examples: isMatch(\"aa\",\"a\") → false isMatch(\"aa\",\"aa\") → true isMatch(\"aaa\",\"aa\") → false isMatch(\"aa\", \"*\") → true isMatch(\"aa\", \"a*\") → true isMatch(\"ab\", \"?*\") → true isMatch(\"aab\", \"c*a*b\") → false 解法(1)：O(n*m) 当 p[jj] == ‘*’ 时，dp[i][j] = dp[i][j-1] | dp[i-1][j]. class Solution { public: bool isMatch(string s, string p) { int n = s.size(), m = p.size(); vector dp_pre(m+1, false); dp_pre[0] = true; for(int j = 1; j dp_cur(m+1, false); for(int j = 1; j 解法(2)：更优的解法。 遇到*的处理：用pstar记下*在串p的位置， 用spos记下对应串s的位置。指针j++。 失配时，指针i, j 回退到spos, pstar的位置重新尝试匹配。即 i = ++spos，j = pstar+1. class Solution { public: bool isMatch(string s, string p) { int n = s.size(), m = p.size(); int i = 0, j = 0, pstar = -1, spos; while(i "},"solutions/46&47. Permutations & Permutations II.html":{"url":"solutions/46&47. Permutations & Permutations II.html","title":"LeetCode 46&47. Permutations","keywords":"","body":"LeetCode 46. Permutations Given a collection of distinct numbers, return all possible permutations. For example, [1,2,3] have the following permutations: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 无重复元素的全排列。 解法一：递归 (非字典序输出) class Solution { public: vector> rst; void solve(int from, vector& nums){ if(from == nums.size()){ rst.push_back(nums); return; } for(int i = from; i > permute(vector& nums) { solve(0, nums); return rst; } }; LeetCode 47. Permutations II Given a collection of numbers that might contain duplicates, return all possible unique permutations. For example, [1,1,2] have the following unique permutations: [ [1,1,2], [1,2,1], [2,1,1] ] 有重复元素的全排列。 解法1: 对最终结果用 set 过滤. 最后 return vector>(set.begin(), set.end()); 解法2: 仅靠以下两个条件是无法完全去重的: if(i != from && nums[i] == nums[from]) continue; if(i > from && nums[i] == nums[i-1]) continue; 对每次循环，而是考虑用unordered_set来去重，即如果该数值已经swap过，表明不需要再swap. (非字典序输出) class Solution { public: vector> rst; void solve(int from, vector& nums){ if(from == nums.size()){ rst.push_back(nums); return; } unordered_set set; for(int i = from; i > permuteUnique(vector& nums) { solve(0, nums); return rst; } }; 解法3: next_permutation (字典序输出) class Solution { public: bool next_permutation(vector& nums){ int n = nums.size(); if(n == 1) return false; int i = n-2; while(i >= 0 && nums[i] >= nums[i+1]) i--; if(i nums[i]) j++; swap(nums[i], nums[--j]); reverse(nums.begin()+i+1, nums.end()); return true; } vector> permuteUnique(vector& nums) { vector > rst; sort(nums.begin(), nums.end()); rst.push_back(nums); while(true){ vector vec(rst.back()); if(next_permutation(vec)){ rst.push_back(vec); }else break; } return rst; } }; "},"solutions/71. Simplify Path.html":{"url":"solutions/71. Simplify Path.html","title":"LeetCode 71. Simplify Path","keywords":"","body":"LeetCode 71. Simplify Path Given an absolute path for a file (Unix-style), simplify it. For example, path = \"/home/\", => \"/home\" path = \"/a/./b/../../c/\", => \"/c\" Corner cases: \"//\" \"/./\" \"/home/../\" \"/../../\" if empty, return \"/\". stack、queue不提供顺序遍历(iterator begin end)，这里用vector或者deque. class Solution { public: string simplifyPath(string path) { vector vec; int i = 1, n = path.size(); while(i 0) vec.pop_back(); } else vec.push_back(str); i = ++j; } if(vec.size() == 0) return \"/\"; string rst; for(int i = 0; i "},"solutions/146. LRU Cache.html":{"url":"solutions/146. LRU Cache.html","title":"LeetCode 146. LRU Cache","keywords":"","body":"LeetCode 146. LRU Cache Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. Follow up: Could you do both operations in O(1) time complexity? Example: LRUCache cache = new LRUCache( 2 /* capacity */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // returns 1 cache.put(3, 3); // evicts key 2 cache.get(2); // returns -1 (not found) cache.put(4, 4); // evicts key 1 cache.get(1); // returns -1 (not found) cache.get(3); // returns 3 cache.get(4); // returns 4 利用双向链表实现O(1)的删除、插入元素，用hashmap来实现O(1)的查找。 list即是STL中的双向链表结构。 class LRUCache { public: LRUCache(int capacity) { m_capacity = capacity; } int get(int key) { auto it = m_map.find(key); if(it == m_map.end()) return -1; int val = it->second->second; m_list.erase(it->second); m_list.push_front(make_pair(key, val)); m_map[key] = m_list.begin(); return val; } void put(int key, int value) { auto it = m_map.find(key); if(it == m_map.end()){ if(m_capacity == m_list.size()){ m_map.erase(m_map.find(m_list.back().first)); m_list.pop_back(); } m_list.push_front(make_pair(key, value)); m_map[key] = m_list.begin(); }else{ m_list.erase(it->second); m_list.push_front(make_pair(key, value)); m_map[key] = m_list.begin(); } } private: int m_capacity; list> m_list; // unordered_map>::iterator> m_map; }; "},"solutions/148. Sort List.html":{"url":"solutions/148. Sort List.html","title":"LeetCode 148. Sort List","keywords":"","body":"LeetCode 148. Sort List Sort a linked list in O(n log n) time using constant space complexity. 链表排序。 解法1：mergeSort. class Solution { public: ListNode* merge(ListNode* head1, ListNode* head2){ ListNode* H = new ListNode(0), *tail = H; while(head1 && head2){ if(head1->val val){ tail->next = head1; head1 = head1->next; }else{ tail->next = head2; head2 = head2->next; } tail = tail->next; } if(head1) tail->next = head1; if(head2) tail->next = head2; return H->next; } ListNode* mergeSort(ListNode* head, int n){ if(n next; ListNode *h2 = p->next; p->next = NULL; //注意这里 ListNode* head1 = mergeSort(head, n/2); ListNode* head2 = mergeSort(h2, n-n/2); return merge(head1, head2); // 最后merge } ListNode* sortList(ListNode* head) { int n = 0; ListNode* p = head; while(p){ p = p->next; n++; } return mergeSort(head, n); } }; 另一种找middle结点的方式：fast, slow指针。 这里有一个技巧，为了找到middle结点的前继结点，初始化时让fast从第二个结点开始。 ListNode* mergeSort(ListNode* head) { if(head == NULL || head->next == NULL) return head; ListNode *fast = head->next, *slow = head; // 技巧：fast从第二个结点开始 while(fast && fast->next){ fast = fast->next->next; slow = slow->next; } ListNode* h2 = slow->next; slow->next = NULL; //注意这里 ListNode* head1 = mergeSort(head); ListNode* head2 = mergeSort(h2); return merge(head1, head2); // 最后merge } 解法2：不用栈空间，非递归版 mergeSort. （待补充） 解法3：quickSort. 一开始的写法，未AC，对某些例子TLE。。。 class Solution { public: ListNode* quickSort(ListNode* head){ if(head == NULL) return head; ListNode* H = new ListNode(0), *tail = H, *p = head->next, *pre = head; while(p){ if(p->val val){ ListNode *q = p; pre->next = pre->next->next; tail->next = q; tail = tail->next; p = pre->next; }else{ p = p->next; pre = pre->next; } } tail->next = NULL; ListNode* head1 = quickSort(H->next); ListNode* head2 = quickSort(head->next); // head is pivot head->next = head2; if(head1 == NULL){ // 注意判断head1可能为NULL return head; }else{ tail = head1; while(tail->next) tail = tail->next; tail->next = head; return head1; } } ListNode* sortList(ListNode* head) { return quickSort(head); } }; 参考了discuss的写法，分为三段 small, equal, large. class Solution { public: ListNode* quickSort(ListNode* head){ if(head == NULL) return head; ListNode* small = new ListNode(0), *equal = new ListNode(0), *large = new ListNode(0); ListNode* tail1 = small, *tail2 = equal, *tail3 = large, *p = head; while(p){ if(p->val val){ tail1->next = p; tail1 = tail1->next; }else if(p->val == head->val){ tail2->next = p; tail2 = tail2->next; }else{ tail3->next = p; tail3 = tail3->next; } p = p->next; } tail1->next = NULL; tail2->next = NULL; tail3->next = NULL; ListNode* head1 = quickSort(small->next); ListNode* head2 = quickSort(large->next); tail2->next = head2; if(head1 == NULL){ // 注意判断head1可能为NULL return equal->next; }else{ p = head1; while(p->next) p = p->next; p->next = equal->next; return head1; } } ListNode* sortList(ListNode* head) { return quickSort(head); } }; "},"solutions/322&518. Coin Change.html":{"url":"solutions/322&518. Coin Change.html","title":"LeetCode 322&518. Coin Change","keywords":"","body":"LeetCode 322. Coin Change You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1: coins = [1, 2, 5], amount = 11 return 3 (11 = 5 + 5 + 1) Example 2: coins = [2], amount = 3 return -1. Note: You may assume that you have an infinite number of each kind of coin. 可重复取。for循环为正向。 class Solution { public: int coinChange(vector& coins, int amount) { int n = coins.size(); int INF = amount+1; vector dp(amount+1, INF); dp[0] = 0; for(int i = 0; i LeetCode 518. Coin Change 2 You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin. Note: You can assume that 0 1 the number of coins is less than 500 the answer is guaranteed to fit into signed 32-bit integer Example 1: Input: amount = 5, coins = [1, 2, 5] Output: 4 Explanation: there are four ways to make up the amount: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1 Example 2: Input: amount = 3, coins = [2] Output: 0 Explanation: the amount of 3 cannot be made up just with coins of 2. Example 3: Input: amount = 10, coins = [10] Output: 1 可重复取。for循环为正向。 不同于LeetCode 377. Combination Sum IV，对 LeetCode-337 求得是排序数，即(1, 1, 2), (1, 2, 1), (2, 1, 1)看作不同的解。故第一层for 先循环amount, 然后再循环每个元素. 这里，若第一层循环为 for(int i = 1; i 以 f(3)为例, f(3) = {1+f(2), 2+f(1), 3+f(0)}. 显然 1+f(2)和2+f(1)存在重复的解. 实际上,该方式求的是不同硬币的排列数. 正确的解法. 对当前元素 coins[i], dp[j]实际上存的是由前 i-1 个面值构成的解集. 然后对所有的 dp[j]再更新为加上 coins[i]之后的解. class Solution { public: int change(int amount, vector& coins) { int n = coins.size(); vector dp(amount+1, 0); dp[0] = 1; for(int i = 0; i "}}